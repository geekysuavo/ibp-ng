
/* include the psf header. */
#include "psf.h"

/* psf_write(): write an intermediate PSF file containing the peptide
 * topology information used for reading molecules generated by ibp-ng
 * into other programs.
 *
 * arguments:
 *  @fname: output filename to write data into.
 *  @P: pointer to the peptide structure to utilize.
 *  @G: pointer to the graph structure to utilize.
 *
 * returns:
 *  integer indicating whether (1) or not (0) the operation succeeded.
 */
int psf_write (const char *fname, peptide_t *P, graph_t *G) {
  /* declare required variables:
   *  @i: peptide array atom/bond/torsion loop counter.
   *  @j: psf output atom/bond/torsion loop counter.
   *  @n: maximum value with respect to @j.
   *  @ids: handle on atom index arrays.
   *  @map: mapping between peptide atom index and output atom index.
   *  @atom: peptide atom structure pointer.
   *  @fh: output file handle.
   */
  unsigned int i, j, n, *ids, *map;
  peptide_atom_t *atom;
  FILE *fh;

  /* open the output file. */
  fh = fopen(fname, "w");
  if (!fh)
    throw("unable to open '%s' for writing", fname);

  /* allocate the index map. */
  map = (unsigned int*) malloc(P->n_atoms * sizeof(unsigned int));

  /* check that allocation was successful. */
  if (!map) {
    /* close the output file and throw an exception. */
    fclose(fh);
    throw("unable to allocate index array");
  }

  /* initialize the index map. */
  memset(map, 0, P->n_atoms * sizeof(unsigned int));

  /* write the header. */
  fprintf(fh, "PSF\n\n");
  fprintf(fh, "%8u !NTITLE\n", 2);
  fprintf(fh, " REMARKS FILENAME=\"%s\"\n", fname);
  fprintf(fh, " REMARKS Generated automatically by ibp-ng\n\n");

  /* write the atom list. */
  fprintf(fh, "%8u !NATOM\n", G->n_orig);
  for (i = 0, j = 1; i < G->nv; i++) {
    /* skip non-original atoms in the order. */
    if (G->ordrev[i] >= G->n_order)
      continue;

    /* get the atom structure pointer and store the output atom index
     * into the index map.
     */
    atom = P->atoms + i;
    map[i] = (unsigned int) j;

    /* print the atom information. */
    fprintf(fh, "%8d%8u    %s  %-4s %-4s  %9.6lf       %7.4lf%12u\n",
            j, atom->res_id + 1, peptide_get_resname(P, atom->res_id),
            atom->name, atom->type, atom->charge, atom->mass, 0);

    /* increment the output index. */
    j++;
  }

  /* determine the number of output bonds. */
  for (i = n = 0; i < P->n_bonds; i++) {
    ids = P->bonds[i].atom_id;
    if (P->bonds[i].is_virtual == 0 && map[ids[0]] && map[ids[1]])
      n++;
  }

  /* write the bond list. */
  fprintf(fh, "\n%8u !NBOND: bonds\n", n);
  for (i = j = 0; i < P->n_bonds; i++) {
    /* skip incompletely mapped entries. */
    ids = P->bonds[i].atom_id;
    if (P->bonds[i].is_virtual || !map[ids[0]] || !map[ids[1]])
      continue;

    /* output the bond information. */
    fprintf(fh, "%8u%8u", map[ids[0]], map[ids[1]]);
    if ((j + 1) % 4 == 0 && j < n - 1)
      fprintf(fh, "\n");

    /* increment the output index. */
    j++;
  }

  /* determine the number of output angles. */
  for (i = n = 0; i < P->n_angles; i++) {
    ids = P->angles[i].atom_id;
    if (map[ids[0]] && map[ids[1]] && map[ids[2]]) n++;
  }

  /* write the angle list. */
  fprintf(fh, "\n\n%8u !NTHETA: angles\n", n);
  for (i = j = 0; i < P->n_angles; i++) {
    /* skip incompletely mapped entries. */
    ids = P->angles[i].atom_id;
    if (!map[ids[0]] || !map[ids[1]] || !map[ids[2]])
      continue;

    /* output the angle information. */
    fprintf(fh, "%8u%8u%8u", map[ids[0]], map[ids[1]], map[ids[2]]);
    if ((j + 1) % 3 == 0 && j < n - 1)
      fprintf(fh, "\n");

    /* increment the output index. */
    j++;
  }

  /* determine the number of output torsions. */
  for (i = n = 0; i < P->n_torsions; i++) {
    ids = P->torsions[i].atom_id;
    if (map[ids[0]] && map[ids[1]] && map[ids[2]] && map[ids[3]]) n++;
  }

  /* write the torsion list. */
  fprintf(fh, "\n\n%8u !NPHI: dihedrals\n", n);
  for (i = j = 0; i < P->n_torsions; i++) {
    /* skip incompletely mapped entries. */
    ids = P->torsions[i].atom_id;
    if (!map[ids[0]] || !map[ids[1]] || !map[ids[2]] || !map[ids[3]])
      continue;

    /* output the torsion information. */
    fprintf(fh, "%8u%8u%8u%8u",
            map[ids[0]], map[ids[1]],
            map[ids[2]], map[ids[3]]);

    /* write a newline, if necessary. */
    if ((j + 1) % 2 == 0 && j < n - 1)
      fprintf(fh, "\n");

    /* increment the output index. */
    j++;
  }

  /* determine the number of output impropers. */
  for (i = n = 0; i < P->n_impropers; i++) {
    ids = P->impropers[i].atom_id;
    if (map[ids[0]] && map[ids[1]] && map[ids[2]] && map[ids[3]]) n++;
  }

  /* write the improper list. */
  fprintf(fh, "\n\n%8u !NIMPHI: impropers\n", n);
  for (i = j = 0; i < P->n_impropers; i++) {
    /* skip incompletely mapped entries. */
    ids = P->impropers[i].atom_id;
    if (!map[ids[0]] || !map[ids[1]] || !map[ids[2]] || !map[ids[3]])
      continue;

    /* write the improper information. */
    fprintf(fh, "%8u%8u%8u%8u",
            map[ids[0]], map[ids[1]],
            map[ids[2]], map[ids[3]]);

    /* write a newline, if necessary. */
    if ((j + 1) % 2 == 0 && j < n - 1)
      fprintf(fh, "\n");

    /* increment the output index. */
    j++;
  }

  /* write the ending newlines. */
  fprintf(fh, "\n\n");

  /* close the output file and free the index map. */
  fclose(fh);
  free(map);

  /* return success. */
  return 1;
}

